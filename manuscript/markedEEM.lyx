#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble

\usepackage{amsthm}\usepackage{epsfig}\usepackage{psfrag}\usepackage{lineno}

\bibliographystyle{apalike}

%\setlength{\evensidemargin}{0in} \setlength{\oddsidemargin}{0in}
%\setlength{\topmargin}{0.0in} \setlength{\textwidth}{6.5in}
%\setlength{\textheight}{9in} \setlength{\topskip}{0in}
%\setlength{\headheight}{0in} \setlength{\headsep}{0in}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% TITLE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset FormulaMacro
\newcommand{\baselinestretch}{1.8}
\end_inset


\end_layout

\begin_layout Standard
\align center

\family typewriter
\size largest
marked
\family default
: An R package for maximum-likelihood and MCMC analysis of capture-recapture
 data
\size normal

\begin_inset VSpace 0.5in
\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
Jeff L.
 Laake
\begin_inset Formula $^{1}$
\end_inset

, Devin S.
 Johnson, and Paul B.
 Conn
\end_layout

\begin_layout Standard
\align center

\size normal
\begin_inset space \hrulefill{}
\end_inset


\end_layout

\begin_layout Standard
\align center

\size normal
\begin_inset FormulaMacro
\renewcommand{\baselinestretch}{1.25}
\end_inset


\size large
National Marine Mammal Laboratory, Alaska Fisheries Science Center
\begin_inset Newline newline
\end_inset

 NOAA National Marine Fisheries Service,
\begin_inset Newline newline
\end_inset

 Seattle, Washington, U.S.A.
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $^{1}$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 Email:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 jeff.laake@noaa.gov
\end_layout

\begin_layout Standard
\align center

\size large
\begin_inset space \hrulefill{}
\end_inset


\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size normal
Running Head
\shape default
: Running header 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\size normal
July 13, 2012 
\end_layout

\begin_layout Standard

\size normal
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard

\size normal
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% ABSTRACT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size normal
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%{
\backslash
sc Summary.}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\series bold
Summary
\end_layout

\begin_layout Standard
\noindent

\size normal
\begin_inset space \hrulefill{}
\end_inset


\end_layout

\begin_layout Standard
\noindent

\shape smallcaps
\size normal
Key words
\shape default
 Words here
\end_layout

\begin_layout Standard

\size normal
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard

\size normal
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
linenumbers
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size normal
\begin_inset FormulaMacro
\renewcommand{\baselinestretch}{1.0}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\baselinestretch}{1.0}
\end_inset


\end_layout

\begin_layout Standard
Currently the most comprehensive software for analysis of capture-recapture
 data is MARK (
\begin_inset CommandInset citation
LatexCommand citealt
key "White1999"

\end_inset

).
 MARK is a FORTRAN program for fitting capture-recapture models that are
 manually constructed with a graphical user interface.
 RMark (
\begin_inset CommandInset citation
LatexCommand citealt
key "Laake2008"

\end_inset

) is an R package that constructs models for MARK with user-specified formulas
 to replace the manual model creation.
 With RMark and MARK most currently available capture-recapture models can
 be fitted and manipulated in R.
 Additional R packages for analysis of capture-recapture data have been
 made available including Rcapture (
\begin_inset CommandInset citation
LatexCommand citealt
key "Baillargeon2007"

\end_inset

), mra (
\begin_inset CommandInset citation
LatexCommand citealt
key "McDonald2005"

\end_inset

), secr (
\begin_inset CommandInset citation
LatexCommand citealt
key "Borchers2008"

\end_inset

), BTSPAS (
\begin_inset CommandInset citation
LatexCommand citealt
key "Schwarz2009"

\end_inset

), SPACECAP (
\begin_inset CommandInset citation
LatexCommand citealt
key "Royle2009"

\end_inset

), and BaSTA (
\begin_inset CommandInset citation
LatexCommand citealt
key "Colchero2012"

\end_inset

).
 Rcapture fits closed and open models in a log-linear framework.
 The mra package fits Cormack-Jolly-Seber (CJS) and the Huggins closed model
 with a 
\begin_inset Quotes eld
\end_inset

regression approach
\begin_inset Quotes erd
\end_inset

 to model specification.
 The secr and SPACECAP packages provide spatially explicit modeling of closed
 capture-recapture data and BTSPAS fits time-stratified Petersen models
 in a Bayesian framework.
 BaSTA estimates survival with covariates from capture-recapture/recovery
 data in a Bayesian framework when many individuals are of unknown age.
 Each package is designed for a unique niche or structure.
 We believe these alternative packages in R are useful because they expand
 the analyst's toolbox and the code is open source which enables the knowledgeab
le user to understand fully what the software is doing.
 Also, this independent innovation provides testing for existing software
 and potential gains in developer knowledge to improve existing software.
\end_layout

\begin_layout Standard
We developed an R package we named 
\begin_inset Quotes eld
\end_inset

marked
\begin_inset Quotes erd
\end_inset

 for analysis with marked animals in contrast to the R package unmarked
 (
\begin_inset CommandInset citation
LatexCommand citealt
key "Fiske2011"

\end_inset

) that focuses on analysis with unmarked animals.
 The original impetus for the package was to implement the CJS model using
 the hierarchical likelihood construction described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Pledger2003"

\end_inset

 and to improve on execution times with RMark/MARK for analysis of our own
 large data sets with many time-varying individual (animal-specific) covariates.
 Subsequently, we implemented the Jolly-Seber model with the 
\begin_inset CommandInset citation
LatexCommand citet
key "Schwarz1996"

\end_inset

 POPAN structure where the hierarchical likelihood construction idea extended
 to the entry of animals into the population.
 We also added a Bayesian Markov Chain Monte Carlo (MCMC) implementation
 of the CJS model based on the 
\size normal
approach used by 
\begin_inset CommandInset citation
LatexCommand citet
key "ALBERT:1993fk"

\end_inset

 for analyzing binary data with a probit regression model.
 
\end_layout

\begin_layout Section*
Model construction
\end_layout

\begin_layout Standard
The manner in which models are constructed in the marked package is different
 than in MARK.
 We start by describing how MARK specifies and constructs models and how
 the marked package differs.
 The likelihood for CJS/JS is a product multinomial and the multinomial
 cell probabilities are functions of the parameters.
 We will focus on CJS which has two types of parameters: 
\begin_inset Formula $p$
\end_inset

 (capture/recapture probability) and 
\begin_inset Formula $\phi$
\end_inset

 (apparent survival).
 Each cell is associated with a release cohort and recapture time (occasion).
 The cohorts can be further split into groups based on categorical variables
 (e.g., sex).
 In MARK, a parameter index matrix (PIM) is used to specify the parameters.
 Each cell can have a unique index for each type of parameter type (e.g.,
 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $\phi$
\end_inset

).
 As a very simple example, we will consider a CJS model for a single group
 with k=4 occasions.
 For this structure the PIMS are triangular with a row for each cohort released
 at each occasion (time) and the column representing the occasions (times)
 following the release.
 Using an unique index for each potential parameter, the PIMS would be:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cohort
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cohort
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
The index 5 represents survival of the second release cohort between occasions
 3 and 4 and index 8 represents recapture probability of the first release
 cohort on the third occasion.
 A separate set of PIMS is created for each group defined in the data.
 For this example, if there were 
\shape italic
g
\shape default
 groups there would be 
\shape italic
g
\shape default
*12 possible unique indices.
\end_layout

\begin_layout Standard
Some reduced models with constraints on parameters can be constructed by
 modifying the PIMS.
 For example, a model with constant survival and capture probability (Phi(.)p(.))
 could be specified by setting all of the PIM values to 1 for the 
\begin_inset Formula $\phi$
\end_inset

 PIM and 2 for the 
\begin_inset Formula $p$
\end_inset

 PIM.
 Not all reduced models can be specified by modifying the PIMS and more
 generally reduced models are constructed with a design matrix which is
 a set of linear constraints.
 Each parameter index specifies a row in the design matrix which can be
 used to apply constraints on the parameters and to relate covariates to
 the parameters.
 The PIM approach minimizes the work of manually creating a design matrix
 by reducing the set of potential parameters and thus the number of rows
 in the design matrix.
 For our example, there would be 12 rows in the design matrix and each column
 in the design matrix (
\begin_inset Formula $X$
\end_inset

) represents one of the parameters in the vector
\begin_inset Formula $\beta$
\end_inset

.
 If a logit link is used, the real parameters 
\begin_inset Formula $\theta$
\end_inset

 (e.g., 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

 in CJS) are:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{equation}
\theta=\frac{1}{1+\exp(-X\beta)}\label{eq:link}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
To specify the Phi(.)p(.) model, the design matrix (
\begin_inset Formula $X$
\end_inset

) would have 12 rows and 2 columns.
 The first column in 
\begin_inset Formula $X$
\end_inset

 would have a 1 in the first six rows (indices 1-6) and a 0 in the last
 six rows (indices 7-12).
 The second column would have 0 in the first six rows and a 1 in the last
 6 rows.
 The resulting model would have two parameters with the first representing
 
\begin_inset Formula $\phi$
\end_inset

 and the second 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Standard
To automate the creation of design matrices with formula, the RMark package
 creates 
\begin_inset Quotes eld
\end_inset

design data
\begin_inset Quotes erd
\end_inset

 which are data about the parameters like cohort, time, group, and any related
 variables.
 However, having a single 
\begin_inset Formula $X$
\end_inset

 becomes problematic with individual covariates (variables that differ for
 animals in the same group/cohort).
 In MARK, these individual covariates are entered into the design matrix
 as a covariate name.
 When the real parameters are computed, the name of the covariate is replaced
 with the value for an animal.
 If there are only a few individual covariates and small number of animals,
 the time required for replacement and computation is minor, but when the
 individual covariates differ in time, there is a different covariate name
 for each time and most rows in the design matrix must be recomputed which
 results in longer execution times for large models.
 
\end_layout

\begin_layout Standard
Even if computation time is not limiting, we agree with 
\begin_inset CommandInset citation
LatexCommand citet
key "McDonald2005"

\end_inset

 that the PIMs used in MARK can be quite confusing to the novice user because
 they are an additional layer of abstraction from the data.
 PIMS are useful for manual model creation, but they become an unnecessary
 nuisance when models and design matrices are created with formula.
 Explicit PIMS can be avoided by having an underlying real parameter for
 each animal for each occasion regardless of the release cohort.
 It can be viewed as a rectangular matrix with a column for each animal
 and a row for each occasion.
 That was the solution of 
\begin_inset CommandInset citation
LatexCommand citet
key "McDonald2005"

\end_inset

 who in their mra package use a rectangular covariate matrices as predictor
 for the real parameters as in standard regression.
 
\end_layout

\begin_layout Standard
We use a similar approach that we believe is simpler for the user.
 For a specified model structure (e.g., CJS), the marked package creates from
 the raw data, a list of dataframes.
 Each dataframe contains the covariate data for a type of parameter in the
 model (e.g., 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

).
 The dataframes contain a record for each animal-occasion and the columns
 are the covariates.
 Each record contains the covariate values for that animal-occasion.
 If the covariate is constant across time then the value is the same value
 in each record for an animal and the value may be different for each occasion
 if the covariate is time-varying.
 Time-varying covariates must be named in the raw data in a certain manner
 and specified in the processing step.
 Each column in the dataframe is a vector that is equivalent to one of the
 covariate matrices in mra; however, rather than specifying the model as
 a set of covariate matrices, the standard R model formula (e.g., ~time+sex)
 can be used with the dataframe for each parameter which is even closer
 to a typical regression analysis.
\end_layout

\begin_layout Standard
A separate dataframe is created for each parameter to allow different data
 (e.g., time values for 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

) and number of occasions (e.g., 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

 in CJS) for each parameter.
 For 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

 in the CJS model, there are 
\begin_inset Formula $n(k-1)$
\end_inset

 rows for 
\begin_inset Formula $n$
\end_inset

 animals and 
\begin_inset Formula $k-1$
\end_inset

 occasions for each parameter but time is labeled by 1 to 
\begin_inset Formula $k-1$
\end_inset

 for 
\begin_inset Formula $\phi$
\end_inset

 and 2 to 
\begin_inset Formula $k$
\end_inset

 for 
\begin_inset Formula $p$
\end_inset

.
 For the JS model, there are 
\begin_inset Formula $n(k-1)$
\end_inset

 records for survival probability and entry probability, but for capture
 probability there are 
\begin_inset Formula $nk$
\end_inset

 records because the initial capture event is modeled.
 
\end_layout

\begin_layout Standard
The parameter-specific animal-occasion dataframes are automatically created
 from the user's data which contain a single record per animal containing
 the capture history and any covariates.
 Some covariates like cohort, age, and time are generated automatically
 for each record.
 Other static and time-varying covariates specified in the data are added.
 Static variables (e.g., sex) are repeated for each occasion for each animal.
 Time-varying covariates are specified in the data using a naming convention
 of 
\begin_inset Quotes eld
\end_inset

vt
\begin_inset Quotes erd
\end_inset

 where 
\begin_inset Quotes eld
\end_inset

v
\begin_inset Quotes erd
\end_inset

 is the covariate name and 
\begin_inset Quotes eld
\end_inset

t
\begin_inset Quotes erd
\end_inset

 is a numeric value for the time (occasion) (e.g., td19 contains the value
 of covariate td at time 19).
 The time-varying covariates are collapsed in the animal-occasion dataframes
 to a single column with the name identified by 
\begin_inset Quotes eld
\end_inset

v
\begin_inset Quotes erd
\end_inset

 and each record contains the appropriate value for the occasion.
 All of this is transparent to the user who only needs to specify a dataframe,
 the type of model (e.g., CJS), the variables that should be treated as time-varyi
ng, and the formula for each parameter.
\end_layout

\begin_layout Standard
With the R function model.matrix, the formula is applied to the dataframe
 to create the design matrix for each parameter (e.g, 
\begin_inset Formula $X_{\phi}$
\end_inset

,
\begin_inset Formula $X_{p}$
\end_inset

).
 They are each equivalent to a portion of the design matrix in MARK for
 an animal which are then 
\begin_inset Quotes eld
\end_inset

stacked on top of one another
\begin_inset Quotes erd
\end_inset

 to make a matrix for all animals.
 For maximum likelihood estimation (MLE), equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:link"

\end_inset

 (or similar inverse link function) is applied and the resulting vector
 is converted to a matrix with 
\begin_inset Formula $n$
\end_inset

 rows and a column for each required occasion (
\begin_inset Formula $k-1$
\end_inset

 or 
\begin_inset Formula $k$
\end_inset

).
 For Bayesian MCMC inference in marked, only
\begin_inset Formula $X\beta$
\end_inset

 are needed for updating.
\end_layout

\begin_layout Section*
Model fitting 
\end_layout

\begin_layout Standard
Currently there are only three types of models implemented in the marked
 package: 1) CJS, 2) JS, and 3) probitCJS.
 The first two are based on MLE and the third is an MCMC implementation
 as described by (Johnson and Conn in prep).
 The likelihoods for CJS and JS were developed hierarchically as described
 by 
\begin_inset CommandInset citation
LatexCommand citet
key "Pledger2003"

\end_inset

 for CJS.
 For simplicity we only consider a single animal to avoid the additional
 subscript.
 Let 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\omega$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
be a capture history 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
vector having value 
\begin_inset Formula $\omega_{j}$
\end_inset

= 1 when the animal was initially captured and released or recaptured at
 occasion 
\family default
\series default
\shape italic
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
j
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 and 
\begin_inset Formula $\omega_{j}$
\end_inset

= 0 if the animal was not captured on occasion 
\family default
\series default
\shape italic
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
j
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
, for occasions 
\family default
\series default
\shape italic
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
j
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
=1,...k.
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
The probability of observing a particular capture history 
\begin_inset Formula $Pr(\omega)$
\end_inset

 for CJS can be divided into two pieces (
\begin_inset Formula $Pr(\omega)=Pr(\omega_{1})Pr(\omega_{2})$
\end_inset

: 1) 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\omega_{1}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 is the portion of the capture history from the initial release (i.e., first
 1) to the last occasion it was sighted (i.e., last 1), and 2) 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\omega_{2}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 is from the last 1 to the last occasion.
 
\begin_inset Formula $Pr(\omega_{1})$
\end_inset

 is easily computed because the time period when the animal was available
 for capture is known but 
\begin_inset Formula $Pr(\omega_{2})$
\end_inset

 is more difficult to compute because it is unknown whether the animal survived
 until the last occasion, or if it died, when it died.
 Typically, 
\begin_inset Formula $Pr(\omega_{2})$
\end_inset

 has been computed recursively (Nichols 2005).
 A hierarchical construction is more direct and understandable.
 As described in 
\begin_inset CommandInset citation
LatexCommand citet
key "Pledger2003"

\end_inset

, we let 
\shape italic
f
\shape default
 be the occasion an animal was released and let 
\shape italic
d
\shape default
 be the occasion after which the animal is no longer available to be recaptured
 due to death or termination of the study.
 Then 
\begin_inset Formula $Pr(\omega|\, f)=\sum_{d}Pr(\omega|\, f,\, d)Pr(d\,|\, f)$
\end_inset

 where the conditional probability 
\begin_inset Formula $Pr(\omega|\, f,\, d)$
\end_inset

 is:
\begin_inset Formula 
\[
Pr(\omega|\, f,\, d)=\prod_{j=f+1}^{d}p_{j}^{\omega_{j}}(1-p_{j})^{(1-\omega_{j})}
\]

\end_inset

and the departure probability is 
\begin_inset Formula 
\[
Pr(d\,|\, f)=\left(\prod_{j=f}^{d-1}\phi_{j}\right)(1-\phi_{d})
\]

\end_inset

Viewed in this way, it is possible to construct the likelihood values for
 all of the observations with a set of matrices as we describe in the Appendix.
 
\end_layout

\begin_layout Standard
The hierarchical approach is easily extended to JS.
 Now the capture history has an additional component with 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Pr(\omega)=Pr(\omega_{0})Pr(\omega_{1})Pr(\omega_{2})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\omega_{0}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 is the portion of the capture history vector from the first occasion (
\shape italic
j
\shape default
=1) to the occasion the animal was first seen (
\shape italic
j=f
\shape default
).
 The 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Pr(\omega_{0})$
\end_inset

 is similar to
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Pr(\omega_{2})$
\end_inset

 but now it is 
\family default
\series default
\shape italic
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
e
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
, the occasion at which the animal was first available for capture (i.e.,
 entered in the prior interval)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 that is unknown.
 The CJS likelihood provides 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Pr(\omega|\, f)$
\end_inset

 so we only need to compute 
\begin_inset Formula $Pr(\omega_{0})=\sum_{e=0}^{f-1}Pr(\omega_{0}|\, e)\pi_{e}$
\end_inset

 where 
\begin_inset Formula $\pi_{e}$
\end_inset

 is the probability of an animal enters the population in the interval between
 occasion 
\family default
\series default
\shape italic
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
e
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 and 
\family default
\series default
\shape italic
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
e
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
+1 (
\begin_inset Formula $\sum_{e=1}^{k-1}\pi_{e}=1-\pi_{0}$
\end_inset

; pent parameters in MARK and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
specified as 
\begin_inset Formula $\beta$
\end_inset

 by 
\begin_inset CommandInset citation
LatexCommand citet
key "Schwarz1996"

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
) and 
\begin_inset Formula 
\[
Pr(\omega_{0}|\, e)=\left(\prod_{j=e+1}^{f-1}(1-p_{j})\right)p_{f}
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
The JS likelihood also contains a component for animals that entered but
 were never seen.
 The details for the JS likelihood construction are provided in the Appendix.
\end_layout

\begin_layout Standard
The MLEs are obtained numerically by finding the minimum of the negative
 log-likelihood using optimization methods provided through the optimx R
 package (Nash and ).
 The default optimization method is BFGS but you can specify alternate methods
 and several methods used independently or in sequence as described by Nash
 and ().
 Initial values for parameters can either be provided as a constant (e.g.,
 0) or as a vector from the results of a previously fitted similar model.
 If initial values are not specified then they are computed using general
 linear models (GLM) that provide approximations.
 Using the underlying idea in 
\begin_inset CommandInset citation
LatexCommand citet
key "Manly1968"

\end_inset

 we compute initial estimates for capture-probability 
\begin_inset Formula $p$
\end_inset

 for occasions 2 to 
\begin_inset Formula $k-1$
\end_inset

 using a binomial GLM with the formula for 
\begin_inset Formula $p$
\end_inset

 which is fitted to a sequence of Bernoulli random variables that are a
 subset of the capture history values 
\begin_inset Formula $y_{ij}$
\end_inset

 
\begin_inset Formula $i=1,...,n$
\end_inset

 and 
\begin_inset Formula $j=f_{i}+1,...,l_{i}-1$
\end_inset

 where 
\begin_inset Formula $f_{i}$
\end_inset

 and 
\begin_inset Formula $l_{i}$
\end_inset

 are the first and last occasions the 
\begin_inset Formula $i^{th}$
\end_inset

 animal was seen.
 A similar but more ad-hoc idea is used for 
\begin_inset Formula $\phi$
\end_inset

.
 We know the animal is alive between 
\begin_inset Formula $f_{i}$
\end_inset

 and 
\begin_inset Formula $l_{i}$
\end_inset

 and assume that the animal dies at occasion 
\begin_inset Formula $l_{i}+1\leq k$
\end_inset

.
 We use a binomial GLM with the formula for 
\begin_inset Formula $\phi$
\end_inset

 fitted to the 
\begin_inset Formula $y_{ij}^{*}$
\end_inset

 
\begin_inset Formula $i=1,...,n$
\end_inset

 and 
\begin_inset Formula $j=f_{i}+1,...,l_{i}+1\leq k$
\end_inset

 where 
\begin_inset Formula $y_{ij}^{*}$
\end_inset

=1 for 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $j=f_{i}+1,...,l_{i}$
\end_inset

 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $y_{ij}^{*}$
\end_inset

=0 for 
\begin_inset Formula $j=l_{i}+1\leq k$
\end_inset

.
 For 
\begin_inset Formula $\phi$
\end_inset

 and 
\shape italic
p
\shape default
, a logit link is used for MLE and a probit link for MCMC.
 For JS, a log link is used for 
\begin_inset Formula $f^{0}$
\end_inset

, the number never captured and the estimate of super-population size is
 the total number of individual animals plus 
\begin_inset Formula $f^{0}$
\end_inset

.
 Also, for JS a multinomial logit link is used for 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\pi_{e}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 The initial value is set to 0 for any 
\begin_inset Formula $\beta$
\end_inset

 that is not estimated (e.g., 
\begin_inset Formula $p_{K}$
\end_inset

 in CJS or 
\begin_inset Formula $p_{1}$
\end_inset

,
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\pi_{e}$
\end_inset

,
\family default
\series default
\shape italic
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 N
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 for JS)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 
\end_layout

\begin_layout Section*
Dipper data example
\end_layout

\begin_layout Standard
Anyone who has used RMark will find it easy to use marked because it has
 nearly identical syntax and structure with a few minor differences.
 The structure of the input dataframe for marked is also identical to RMark.
 Any dataframe with a character field named 
\begin_inset Quotes eld
\end_inset

ch
\begin_inset Quotes erd
\end_inset

 containing the capture history will work with marked.
 If the capture history represents more than one animal then the dataframe
 should contain the additional numeric field named 
\begin_inset Quotes eld
\end_inset

freq
\begin_inset Quotes erd
\end_inset

, which is the number of animals represented by that capture history.
 However, it is not necessary to accumulate capture histories in that matter
 for the input data because the process.data step will accumulate duplicated
 records by default.
 There can be any number of additional fields, some of which can be used
 as covariates in the analysis.
 Some of the functions in marked and RMark have the same name (e.g., process.data,
 make.design.data), so only one of the packages should be loaded in R to avoid
 aliasing and resulting errors.
\end_layout

\begin_layout Standard
We will start by fitting the simplest CJS model with constant 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

.
 The dipper data contain 294 records with the capture history (ch) and a
 factor variable sex with values Female or Male.
 Models are fitted with the function crm (
\series bold
c
\series default
apture-
\series bold
r
\series default
ecapture 
\series bold
m
\series default
odel).
 After a call to library to attach the package, and data to retrieve the
 dipper data from the package, the model is fitted with crm and assigned
 to the object named model:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=3:5,comment="",prompt=TRUE,message=FALSE>>=
\end_layout

\begin_layout Plain Layout

if(length(grep("RMark",.packages()))!=0)detach("package:RMark") 
\end_layout

\begin_layout Plain Layout

options(width=70)
\end_layout

\begin_layout Plain Layout

library(marked) 
\end_layout

\begin_layout Plain Layout

data(dipper)
\end_layout

\begin_layout Plain Layout

model=crm(dipper)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
For this example, we are using the default CJS model and a default formula
 of ~1 (constant) for each parameter.
 The function crm calls three functions in turn: 1) process.data to process
 the data, 2) make.design.data to create the list of parameter-specific dataframes
, and 3) cjs, to fit the CJS model with the defined formulas.
 The code reports progress and some results as it executes.
 We'll suppress these messages in later examples but show them here to explain
 some of the messages.
 When it processes the data, it collapses the 294 rows into 55 which are
 the unique number of rows in the data including ch and sex.
 After processing, it creates the design data and the design matrices for
 each parameter.
 Prior to the optimization, it also collapses the histories further from
 55 to 32 which it can do here because sex is not used in either formula.
 The final steps are to compute initial values for the parameters and find
 the MLEs with the selected optimization method(s).
 As it progresses, the value of -2log-likelihood is reported every 100 evaluatio
ns of the objective function.
 It is not shown above because there were fewer than 100 function evaluations
 for this example.
 A brief listing of the model results is obtained by typing model which
 invokes the function print.crm because class(model)=
\begin_inset Quotes erd
\end_inset

crm
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE>>=
\end_layout

\begin_layout Plain Layout

model
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The output includes the number of parameters (npar), -2log-likelihood, Akaike's
 Information Criterion (AIC), and the estimates for 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

.
 
\end_layout

\begin_layout Standard
Estimates of precision are not shown because the default is hessian=FALSE
 and it must be set to TRUE to get estimates of precision.
 This default was chosen because the marked package does not count parameters
 from the hessian, so there is no need to compute it for each model as with
 MARK.
 The hessian may never be needed if the model is clearly inferior.
 Also, this allows the model to be fitted again from the final or different
 estimates to check for convergence without the penalty of computing the
 hessian at the final values each time.
 Separate functions (cjs.hessian and js.hessian) are provided to compute and
 store in the model the variance-covariance matrix from the hessian at the
 final estimates as shown below:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

model=cjs.hessian(model)
\end_layout

\begin_layout Plain Layout

model
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Once the hessian as been computed, printing the model will display the standard
 errors and 95% normal confidence intervals for the parameter estimates
 on the link scale (e.g., logit for 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

).
 You can set hessian=TRUE in the call to crm if you want to compute it when
 the model is fitted.
 
\end_layout

\begin_layout Standard
You'll never fit only one model to data, so the most efficient approach
 is to call process.data and make.design.data separately and pass the results
 to crm so they can be used for each fitted model as shown below:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE,results="hide">>=
\end_layout

\begin_layout Plain Layout

dipper.proc=process.data(dipper)
\end_layout

\begin_layout Plain Layout

dipper.ddl=make.design.data(dipper.proc)
\end_layout

\begin_layout Plain Layout

Phi.sex=list(formula=~sex)
\end_layout

\begin_layout Plain Layout

model=crm(dipper.proc,dipper.ddl,model.parameters=list(Phi=Phi.sex),
\end_layout

\begin_layout Plain Layout

          accumulate=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Collapsing capture history records is controlled by the accumulate arguments
 in process.data and crm.
 In the above example, accumulate was TRUE for the process.data step but
 it was turned off for the model fit because it would have not resulted
 in any accumulation with the sex term in the model.
 Typically the default values are optimal but if you are fitting many models
 and most are complex models, then it may save time to accumulate in the
 process data step but not for the model fitting step.
 
\end_layout

\begin_layout Standard
If you fit more than a few models, use crm.wrapper rather than crm.
 It fits a set of models and returns a list with a model selection table
 that summarizes the fit of all the models.
 By default, crm.wrapper stores the model results externally and in the list
 it only stores the names of the files containing the models.
 If you set external=FALSE, then it will store the model results in the
 list as shown in the example below.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE,results="hide">>=
\end_layout

\begin_layout Plain Layout

dipper.proc=process.data(dipper)
\end_layout

\begin_layout Plain Layout

dipper.ddl=make.design.data(dipper.proc)
\end_layout

\begin_layout Plain Layout

fit.models=function()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Phi.sex=list(formula=~sex)
\end_layout

\begin_layout Plain Layout

  Phi.time=list(formula=~time)
\end_layout

\begin_layout Plain Layout

  p.sex=list(formula=~sex)
\end_layout

\begin_layout Plain Layout

  p.dot=list(formula=~1)
\end_layout

\begin_layout Plain Layout

  cml=create.model.list(c("Phi","p"))
\end_layout

\begin_layout Plain Layout

  results=crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,
\end_layout

\begin_layout Plain Layout

                      external=FALSE,accumulate=FALSE)
\end_layout

\begin_layout Plain Layout

  return(results)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

dipper.models=fit.models()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The model selection table is displayed with:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

dipper.models
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
A non-zero value for convergence means the model did not converge.
 If the models are not stored externally, an individual model can be extracted
 from the list with either the model number which is listed in the model
 table or with the model name which is the model formula specifications
 pasted together as shown below:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

dipper.models[[1]]
\end_layout

\begin_layout Plain Layout

dipper.models[["Phi.sex.p.dot"]]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
If the models are stored externally, they can be retrieved with the function
 load.model as shown below:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE,results="hide",echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

dipper.proc=process.data(dipper)
\end_layout

\begin_layout Plain Layout

dipper.ddl=make.design.data(dipper.proc)
\end_layout

\begin_layout Plain Layout

fit.models=function()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Phi.sex=list(formula=~sex)
\end_layout

\begin_layout Plain Layout

  Phi.time=list(formula=~time)
\end_layout

\begin_layout Plain Layout

  p.sex=list(formula=~sex)
\end_layout

\begin_layout Plain Layout

  p.dot=list(formula=~1)
\end_layout

\begin_layout Plain Layout

  cml=create.model.list(c("Phi","p"))
\end_layout

\begin_layout Plain Layout

  results=crm.wrapper(cml,data=dipper.proc, ddl=dipper.ddl,
\end_layout

\begin_layout Plain Layout

                      external=TRUE,accumulate=FALSE)
\end_layout

\begin_layout Plain Layout

  return(results)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

dipper.models=fit.models()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

model=load.model(dipper.models[[1]])
\end_layout

\begin_layout Plain Layout

model
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To make the analysis more interesting, we will add some covariates for Phi
 and p.
 For Phi, we will add a static covariate weight which is a random value
 between 1 and 10.
 For Phi, we also add a time-varying covariate Flood which is the same for
 all dippers but varies by time with a 0 value for times 1,4,5,6 and a value
 of 1 for times 2 and 3.
 For p, we will add a time-varying individual covariate td (trap dependence)
 which is the 0/1 value of the capture from the previous occasion.
 Static covariates are entered in the dataframe in a single column and time-vary
ing covariates have a column and name for each occasion with the appropriate
 time appended at the end of each name.
 In this case, Flood will be Flood1,...,Flood6 and for td it will be td2,...,td7
 because time for Phi is based on the time at the beginning of the interval
 and for p it is the time for the capture occasion.
 Below the names of the covariates in the dataframe are shown after they
 are created:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

data(dipper)
\end_layout

\begin_layout Plain Layout

# Add a dummy weight field which are random values from 1 to 10
\end_layout

\begin_layout Plain Layout

set.seed(123)
\end_layout

\begin_layout Plain Layout

dipper$weight=round(runif(nrow(dipper),0,9),0)+1
\end_layout

\begin_layout Plain Layout

# Add Flood covariate
\end_layout

\begin_layout Plain Layout

Flood=matrix(rep(c(0,1,1,0,0,0),each=nrow(dipper)),ncol=6)
\end_layout

\begin_layout Plain Layout

colnames(Flood)=paste("Flood",1:6,sep="")
\end_layout

\begin_layout Plain Layout

dipper=cbind(dipper,Flood)
\end_layout

\begin_layout Plain Layout

# Add td covariate, but exclude first release as a capture
\end_layout

\begin_layout Plain Layout

# splitCH and process.ch are functions in the marked package
\end_layout

\begin_layout Plain Layout

td=splitCH(dipper$ch)
\end_layout

\begin_layout Plain Layout

td=td[,1:6]
\end_layout

\begin_layout Plain Layout

releaseocc=process.ch(dipper$ch)$first
\end_layout

\begin_layout Plain Layout

releaseocc=cbind(1:length(releaseocc),releaseocc)
\end_layout

\begin_layout Plain Layout

releaseocc=releaseocc[releaseocc[,2]<nchar(dipper$ch[1]),]
\end_layout

\begin_layout Plain Layout

td[releaseocc]=0
\end_layout

\begin_layout Plain Layout

colnames(td)=paste("td",2:7,sep="")
\end_layout

\begin_layout Plain Layout

dipper=cbind(dipper,td)
\end_layout

\begin_layout Plain Layout

# show names
\end_layout

\begin_layout Plain Layout

names(dipper)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next we process the data with the default CJS model and make the design
 data with parameters that identify which covariates to use for each parameter.
 By default, each covariate in the dataframe is added to the design data
 of each parameter but the argument static can be used to limit the variables
 appended and the time-varying argument is needed to identify which covariates
 vary by time and should be collapsed into a single column.
 If we did not include the static argument for Phi, then weight and each
 of the td columns would also be included and for p, weight and each of
 the Flood columns would be included.
 If td was added to the time-varying argument for Phi and Flood was added
 for p, then we would have also needed to add td1 and Flood7 due to the
 different time labels for Phi and p.
 We have no intention to use those variables so it is best to specify what
 is needed.
 After specifying the design lists for Phi and p, they are used in the call
 to make.design.data and the resulting dataframe names are shown below:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE,results="hide">>=
\end_layout

\begin_layout Plain Layout

# Process data 
\end_layout

\begin_layout Plain Layout

dipper.proc=process.data(dipper)
\end_layout

\begin_layout Plain Layout

# Create design data with static and time varying covariates
\end_layout

\begin_layout Plain Layout

design.Phi=list(static=c("weight"),time.varying=c("Flood"))
\end_layout

\begin_layout Plain Layout

design.p=list(static=c("sex"),time.varying=c("td"),
\end_layout

\begin_layout Plain Layout

                        age.bins=c(0,1,20))
\end_layout

\begin_layout Plain Layout

design.parameters=list(Phi=design.Phi,p=design.p)
\end_layout

\begin_layout Plain Layout

ddl=make.design.data(dipper.proc,parameters=design.parameters)
\end_layout

\begin_layout Plain Layout

names(ddl$Phi) 
\end_layout

\begin_layout Plain Layout

names(ddl$p) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next we define the models for Phi and p that we want to fit and call crm.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<comment="",prompt=TRUE,tidy=FALSE,results="hide">>=
\end_layout

\begin_layout Plain Layout

Phi.sfw=list(formula=~Flood+weight)
\end_layout

\begin_layout Plain Layout

p.ast=list(formula=~age+sex+td)
\end_layout

\begin_layout Plain Layout

model=crm(dipper.proc,ddl,hessian=TRUE,
\end_layout

\begin_layout Plain Layout

           model.parameters=list(Phi=Phi.sfw,p=p.ast))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Below we create a range of data values to compute predicted 
\begin_inset Formula $\phi$
\end_inset

 values and then plot the results for Flood and non-Flood years for a range
 of weights.
 Not surprising that the slope for weight is nearly 0 because the weight
 values were generated randomly.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fig=TRUE,comment="",prompt=TRUE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

newdipper=expand.grid(sex=c("Male","Female"),weight=1:10,Flood1=0,
\end_layout

\begin_layout Plain Layout

      Flood2=1,Flood3=1,Flood4=0,Flood5=0,Flood6=0,td2=0,td3=c(0,1),
\end_layout

\begin_layout Plain Layout

      td4=c(0,1),td5=c(0,1),td6=c(0,1),td7=c(0,1)) 
\end_layout

\begin_layout Plain Layout

reals=predict(model,newdata=newdipper,se=TRUE) 
\end_layout

\begin_layout Plain Layout

library(ggplot2)
\end_layout

\begin_layout Plain Layout

reals$Phi$Flood=factor(reals$Phi$Flood,labels=c("Non-flood","Flood"))
\end_layout

\begin_layout Plain Layout

ggplot(reals$Phi,aes(weight,estimate,ymin=lcl,ymax=ucl))+
\end_layout

\begin_layout Plain Layout

       geom_errorbar(width=0.2)+geom_point()+geom_line()+
\end_layout

\begin_layout Plain Layout

       xlab("
\backslash
nWeight")+ylab("Survival
\backslash
n")+facet_grid(Flood~.) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset

probitCJS example.
\end_layout

\begin_layout Section*
Validation and timing
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cache=TRUE,echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Phi.1=list(formula=~1)
\end_layout

\begin_layout Plain Layout

Phi.2=list(formula=~weight+age)
\end_layout

\begin_layout Plain Layout

Phi.3=list(formula=~time+weight)
\end_layout

\begin_layout Plain Layout

Phi.4=list(formula=~sex+weight)
\end_layout

\begin_layout Plain Layout

Phi.5=list(formula=~sex+weight+age)
\end_layout

\begin_layout Plain Layout

Phi.6=list(formula=~region+weight+age)
\end_layout

\begin_layout Plain Layout

Phi.7=list(formula=~region+time+weight)
\end_layout

\begin_layout Plain Layout

Phi.8=list(formula=~region+sex+weight)
\end_layout

\begin_layout Plain Layout

p.1=list(formula=~1)
\end_layout

\begin_layout Plain Layout

p.2=list(formula=~time)
\end_layout

\begin_layout Plain Layout

p.3=list(formula=~sex)
\end_layout

\begin_layout Plain Layout

p.4=list(formula=~td)
\end_layout

\begin_layout Plain Layout

p.5=list(formula=~td+sex)
\end_layout

\begin_layout Plain Layout

p.6=list(formula=~td+sex+age)
\end_layout

\begin_layout Plain Layout

p.7=list(formula=~region+sex+age)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data(dipper)
\end_layout

\begin_layout Plain Layout

dipper=dipper[rep(1:nrow(dipper),each=20),]
\end_layout

\begin_layout Plain Layout

dipper$weight=round(runif(nrow(dipper),0,10),0)
\end_layout

\begin_layout Plain Layout

dipper$region=factor(floor(runif(nrow(dipper),1,10.99)))
\end_layout

\begin_layout Plain Layout

td=splitCH(dipper$ch)
\end_layout

\begin_layout Plain Layout

td=td[,1:6]
\end_layout

\begin_layout Plain Layout

colnames(td)=paste("td",2:7,sep="")
\end_layout

\begin_layout Plain Layout

dipper=cbind(dipper,td)
\end_layout

\begin_layout Plain Layout

age=t(apply(marked:::process.ch(dipper$ch,all=TRUE)$Fplus,1,cumsum))
\end_layout

\begin_layout Plain Layout

colnames(age)=paste("age",1:7,sep="")
\end_layout

\begin_layout Plain Layout

dipper=cbind(dipper,age)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(length(grep("RMark",.packages()))!=0)detach("package:RMark")
\end_layout

\begin_layout Plain Layout

library(marked)
\end_layout

\begin_layout Plain Layout

hessian=FALSE
\end_layout

\begin_layout Plain Layout

crmodel.list=create.model.list(c("Phi","p"))
\end_layout

\begin_layout Plain Layout

t1=system.time({
\end_layout

\begin_layout Plain Layout

	dipper.proc=process.data(dipper,model="cjs",begin.time=1)
\end_layout

\begin_layout Plain Layout

    dipper.ddl=make.design.data(dipper.proc,parameters=list(Phi=list(time.varying="ag
e"),p=list(time.varying=c("td","age"))))
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

t2=system.time({
\end_layout

\begin_layout Plain Layout

crm.list=crm.wrapper(crmodel.list,data=dipper.proc,ddl=dipper.ddl,method="BFGS",hessi
an=hessian)
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# fit same models with calls to mark
\end_layout

\begin_layout Plain Layout

if(length(grep("marked",.packages()))!=0)detach("package:marked")
\end_layout

\begin_layout Plain Layout

library(RMark)
\end_layout

\begin_layout Plain Layout

model.list=create.model.list("CJS")
\end_layout

\begin_layout Plain Layout

t3=system.time({
\end_layout

\begin_layout Plain Layout

	dipper.proc=process.data(dipper,model="CJS",begin.time=1,groups=c("sex","region"))
\end_layout

\begin_layout Plain Layout

    dipper.ddl=make.design.data(dipper.proc)
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

t4=system.time({
\end_layout

\begin_layout Plain Layout

mark.list=mark.wrapper(model.list,data=dipper.proc,ddl=dipper.ddl,output=FALSE)
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

mark.list$model.table=model.table(mark.list,use.AIC=TRUE,use.lnl=TRUE)
\end_layout

\begin_layout Plain Layout

crm.table=crm.list$model.table[,2:6]
\end_layout

\begin_layout Plain Layout

mark.table=mark.list$model.table[,4:8]
\end_layout

\begin_layout Plain Layout

compare=crm.table[order(as.numeric(row.names(crm.table))),]-mark.table[order(as.numeri
c(row.names(mark.table))),]
\end_layout

\begin_layout Plain Layout

compare[abs(compare[,2])>.05,]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# refit mark models with crm initial values
\end_layout

\begin_layout Plain Layout

rerun.mark.list=mark.list
\end_layout

\begin_layout Plain Layout

model.list=model.list[ do.call(order, model.list) ,]
\end_layout

\begin_layout Plain Layout

for(i in 1:nrow(model.list))
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	load(paste(paste(model.list[i,],collapse="."),".rda",sep=""))
\end_layout

\begin_layout Plain Layout

    initial=eval(parse(text=paste(paste(model.list[i,],collapse="."),"$beta",sep="
")))
\end_layout

\begin_layout Plain Layout

    rerun.mark.list[[i]]=eval(parse(text=paste("mark(dipper.proc,dipper.ddl,model.par
ameters=list(Phi=",model.list[i,"Phi"],",p=",model.list[i,"p"],"),initial=initial,
output=FALSE)",sep="")))
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

rerun.mark.list$model.table=model.table(rerun.mark.list,use.AIC=TRUE,use.lnl=TRUE)
\end_layout

\begin_layout Plain Layout

crm.table=crm.list$model.table[,2:6]
\end_layout

\begin_layout Plain Layout

mark.table=rerun.mark.list$model.table[,4:8]
\end_layout

\begin_layout Plain Layout

compare2=crm.table[order(as.numeric(row.names(crm.table))),]-mark.table[order(as.numer
ic(row.names(mark.table))),]
\end_layout

\begin_layout Plain Layout

compare2[abs(compare2[,2])>.05,]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# refit crm models with mark initial values
\end_layout

\begin_layout Plain Layout

if(length(grep("RMark",.packages()))!=0)detach("package:RMark")
\end_layout

\begin_layout Plain Layout

library(marked)
\end_layout

\begin_layout Plain Layout

hessian=FALSE
\end_layout

\begin_layout Plain Layout

rerun.crm.list=crm.list
\end_layout

\begin_layout Plain Layout

dipper.proc=process.data(dipper,model="cjs",begin.time=1)
\end_layout

\begin_layout Plain Layout

dipper.ddl=make.design.data(dipper.proc,parameters=list(Phi=list(time.varying="age"),
p=list(time.varying=c("td","age"))))
\end_layout

\begin_layout Plain Layout

for(i in 1:nrow(crmodel.list))
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	model=paste(crmodel.list[i,"Phi"],crmodel.list[i,"p"],sep=".")
\end_layout

\begin_layout Plain Layout

	initial=rerun.mark.list[[model]]$results$beta$estimate
\end_layout

\begin_layout Plain Layout

	rerun.crm.list[[i]]=eval(parse(text=paste("crm(dipper.proc,dipper.ddl,model.paramete
rs=list(Phi=",crmodel.list[i,"Phi"],",p=",crmodel.list[i,"p"],"),initial=initial)"
,sep="")))
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

compare3=mark.table-model.table(rerun.crm.list)[,2:6]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Summary
\end_layout

\begin_layout Standard
Who should use marked?
\end_layout

\begin_layout Standard
No need to run hessian for poor models
\end_layout

\begin_layout Standard
Individual varying time intervals - marking occurs throughout the year but
 re-sighting at one time
\end_layout

\begin_layout Standard
Faster run times with individual time varying covariates
\end_layout

\begin_layout Standard
Parameter initialization speeds up model fitting
\end_layout

\begin_layout Standard
with the added capability of allowing time intervals between occasions to
 vary for different groups of animals (e.g., initial capture and release timing
 varies and occurs between recapture (resighting) occasions).
 The latter are not easily accomplished in MARK.
 Also, we wanted
\end_layout

\begin_layout Standard
Dis: Code infrastructure not as complete as with MARK - median chat; parameter
 counting; fixed link functions logit/mlogit
\end_layout

\begin_layout Standard

\size normal
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "markedWriteUpBib"

\end_inset


\end_layout

\begin_layout Section*
Appendix
\end_layout

\begin_layout Standard
Here we provide some details for the likelihoods that are computed in cjs.lnl
 and cjs.f for the CJS model and in js.lnl for the JS model.
 Let 
\begin_inset Formula $\phi$
\end_inset

,
\begin_inset Formula $M$
\end_inset

 
\begin_inset Formula $p$
\end_inset

 be 
\begin_inset Formula $n\times k$
\end_inset

 matrices which are functions of the parameters where
\begin_inset Formula $\phi_{ij}$
\end_inset

 is the survival probability for animal 
\begin_inset Formula $i$
\end_inset

 from occasion 
\begin_inset Formula $j-1$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 (
\begin_inset Formula $\phi_{i1}=1$
\end_inset

 ), 
\begin_inset Formula $m_{ij}$
\end_inset

 is the probability of dying in the interval 
\begin_inset Formula $j$
\end_inset

 to 
\begin_inset Formula $j+1$
\end_inset

 (
\begin_inset Formula $m_{ik}=1)$
\end_inset

 and 
\begin_inset Formula $p_{ij}$
\end_inset

 is the capture probability for animal 
\begin_inset Formula $i$
\end_inset

 on occasion 
\begin_inset Formula $j$
\end_inset

 (
\begin_inset Formula $p_{i1}=0$
\end_inset

).
 In addition we define a series of matrices and vectors computed from the
 data in the function process.ch.
 Let 
\begin_inset Formula $C$
\end_inset

 be an 
\begin_inset Formula $n\times k$
\end_inset

 matrix of the capture history values and 
\begin_inset Formula $f_{i}$
\end_inset

and 
\begin_inset Formula $l_{i}$
\end_inset

 are the first and last occasions the 
\begin_inset Formula $i^{th}$
\end_inset

 animal was seen.
 Derived from those values are 
\begin_inset Formula $n\times k$
\end_inset

 matrices 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $F^{+}$
\end_inset

 which contain 0 except that 
\begin_inset Formula $L_{ij}=1\; j\geq l_{i}$
\end_inset

,
\begin_inset Formula $F_{ij}=1\; j\geq f_{i}$
\end_inset

 and 
\begin_inset Formula $F_{ij}^{+}=1\; j>f_{i}$
\end_inset

.
 The likelihood calculation has the following steps where the matrix multiplicat
ion is element-wise and 
\begin_inset Formula $1$
\end_inset

 and represents an 
\begin_inset Formula $n\times k$
\end_inset

 matrix where each element is 1:
\end_layout

\begin_layout Enumerate
Construct the 
\begin_inset Formula $n\times k$
\end_inset

 matrix 
\begin_inset Formula $\phi'=1-F^{+}+\phi F^{+}$
\end_inset

which is the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\phi$
\end_inset

 matrix modified such that 
\begin_inset Formula $\phi_{ij}=1$
\end_inset

 for 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $j\leq f_{i}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Construct the 
\begin_inset Formula $n\times k$
\end_inset

 matrix 
\begin_inset Formula $\phi*$
\end_inset

from 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\phi'$
\end_inset

 where 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\phi_{ij}*=\prod_{i=1}^{j}\phi_{ij}'$
\end_inset

.
\end_layout

\begin_layout Enumerate
Construct the 
\begin_inset Formula $n\times k$
\end_inset

 matrix 
\begin_inset Formula $p'=1-F^{+}+F^{+}(Cp+(1-C)(1-p))$
\end_inset

.
\end_layout

\begin_layout Enumerate
Construct the 
\begin_inset Formula $n\times k$
\end_inset

 matrix 
\begin_inset Formula $p*$
\end_inset

from 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $p'$
\end_inset

 where 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $p_{ij}*=\prod_{i=1}^{j}p_{ij}'$
\end_inset

.
\end_layout

\begin_layout Enumerate
Compute 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $n\times1$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 vector of probabilities of observed capture histories 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Pr(\omega_{i})\; i=1,...,n$
\end_inset

 which are the sums of the rows of 
\begin_inset Formula $LM\phi^{*}p^{*}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Compute the log-likelihood 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{i=1}^{n}\ln(Pr(\omega_{i}))$
\end_inset


\end_layout

\begin_layout Standard
The R code translates from the mathematics quite literally as: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

 Phiprime=1-Fplus + Phi*Fplus
\end_layout

\begin_layout Plain Layout

 Phistar=t(apply(Phiprime,1,cumprod))
\end_layout

\begin_layout Plain Layout

 pprime=(1-Fplus)+Fplus*(C*p+(1-C)*(1-p))
\end_layout

\begin_layout Plain Layout

 pstar=t(apply(pprime,1,cumprod))
\end_layout

\begin_layout Plain Layout

 pomega=rowSums(L*M*Phistar*pstar)
\end_layout

\begin_layout Plain Layout

 lnl=sum(log(pomega))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
While this code is simple it is faster if the apply is replaced with a loop
 because there are far more rows than occasions or replaced with compiled
 code which we did with a FORTRAN subroutine (cjs.f called from cjs.lnl).
\end_layout

\begin_layout Standard
The Jolly-Seber likelihood can be partitioned into 3 components: 1) CJS
 likelihood for 
\begin_inset Formula $Pr(\omega_{1})Pr(\omega_{2})$
\end_inset

 treating the first 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 as a release, 2) a likelihood component for 
\begin_inset Formula $Pr(\omega_{0})$
\end_inset

; entry and first observation, 3) a component for those that entered before
 each occasion but were never seen.
 We define an additional 
\begin_inset Formula $n\times k$
\end_inset

 matrix 
\begin_inset Formula $\pi$
\end_inset

 which are the entry probabilities into the population (specified as 
\begin_inset Formula $\beta$
\end_inset

 by 
\begin_inset CommandInset citation
LatexCommand citet
key "Schwarz1996"

\end_inset

) with the obvious constraint that 
\begin_inset Formula $\sum_{j=0}^{k-1}\pi_{ij}=1$
\end_inset

 and 
\begin_inset Formula $N_{g}\: g=1,...,G$
\end_inset

 is the abundance of animals in each of the defined 
\begin_inset Formula $G$
\end_inset

 groups (e.g., male/female) that were in the population at some time (super-popula
tion size).
 
\begin_inset Formula $N_{g}=n_{g}+f_{g}^{0}$
\end_inset

 where 
\begin_inset Formula $n_{g}$
\end_inset

 is the number observed in the group and 
\begin_inset Formula $f_{g}^{0}$
\end_inset

 are the estimated number of animals in the group that were never seen.
\end_layout

\begin_layout Standard
The same hierarchical approach used for CJS can be used for the second component.
 Construct the capture history probability for a given entry time and then
 sum over all possible entry times.
 .
 The second component is constructed with the following steps:
\end_layout

\begin_layout Enumerate
Construct the 
\begin_inset Formula $n\times k$
\end_inset

 matrix 
\begin_inset Formula $E=(1-p)\phi(1-F)+F$
\end_inset

,
\end_layout

\begin_layout Enumerate
Construct the 
\begin_inset Formula $n\times k$
\end_inset

 matrix 
\begin_inset Formula $E*$
\end_inset

where 
\begin_inset Formula $E_{ij}*=\prod_{l=j}^{k}E_{il}$
\end_inset

,
\end_layout

\begin_layout Enumerate
Compute 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $n\times1$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 vector of probabilities 
\begin_inset Formula $Pr(\omega')$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 which are the sums of the rows of 
\begin_inset Formula $E*(1-F^{+})\pi$
\end_inset

 multiplied by the vector 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $p_{if_{i}}\: i=1,...,n$
\end_inset

, 
\end_layout

\begin_layout Enumerate
Compute the log-likelihood 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{i=1}^{n}\ln(Pr(\omega_{i}'))$
\end_inset

.
\end_layout

\begin_layout Standard
For the third likelihood component for missed animals, we constructed 
\begin_inset Formula $G\times k$
\end_inset

 dummy capture histories of all 0's except for a 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 at the occasion the animals entered.
 From the CJS portion of the code, we obtained 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $p_{gj}^{0}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 the probability that an animal released in group 
\begin_inset Formula $g$
\end_inset

 on occasion 
\begin_inset Formula $j$
\end_inset

 would never be captured.
 The final log-likelihood component is:
\begin_inset Formula 
\[
\sum_{g=1}^{G}f_{g}^{0}\ln\left[\sum_{j=1}^{k}\pi_{g,j-1}(1-p_{gj})p_{gj}^{0}\right]+\ln(N_{g}!)-\ln(f_{g}^{0}!)
\]

\end_inset


\end_layout

\begin_layout Standard
The JS log-likelihood is the total of the 3 components plus 
\begin_inset Formula $-\sum_{g=1}^{G}\sum_{j=1}^{k}\ln(n_{gj}!)$
\end_inset

 which do not depend on the parameters but is added after optimization in
 function js, to be consistent with the output from MARK.
\end_layout

\begin_layout Standard
With the structure we have used, the design matrices can become quite large
 and available memory could become limiting.
 For the design matrices, we use sparse matrices with the R package Matrix
 (citation).
 In addition, for MLE analysis, we use the following to reduce the required
 memory:
\end_layout

\begin_layout Enumerate
We reduce the data to 
\begin_inset Formula $n^{*}\leq n$
\end_inset

 individuals by aggregating records with identical data and using the frequencie
s (
\begin_inset Formula $f_{1},...,f_{n^{*}};n=\sum_{i=1\:}^{n^{*}}f_{i}$
\end_inset

) in the likelihood.
 
\end_layout

\begin_layout Enumerate
We construct the design matrix 
\begin_inset Formula $X$
\end_inset

 incrementally with a user-specified size of data chunk that is processed
 at one time.
\end_layout

\begin_layout Enumerate
We retain only the rows of 
\begin_inset Formula $X$
\end_inset

 which are unique for the design and including any fixed parameters which
 can be animal-specific.
 
\end_layout

\begin_layout Standard
For Bayesian MCMC inference, we cannot aggregate records but we reduce the
 required memory by:
\end_layout

\begin_layout Enumerate
Eliminating the unused animal-occasion data for occasions prior to and including
 the release occasion for the animal, and
\end_layout

\begin_layout Enumerate
Storing only the unique values of the real parameters which are unique rows
 of 
\begin_inset Formula $X_{\phi}$
\end_inset

and 
\begin_inset Formula $X_{p}$
\end_inset

.
\end_layout

\end_body
\end_document
