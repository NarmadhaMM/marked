% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvmscjs.R
\name{mvmscjs}
\alias{mvmscjs}
\title{Fitting function for Multivariate Multistate CJS with uncertainty models}
\usage{
mvmscjs(x, ddl, dml, model_data = NULL, parameters, accumulate = TRUE,
  initial = NULL, method, hessian = FALSE, debug = FALSE,
  chunk_size = 1e+07, refit, itnmax = NULL, control = NULL, scale,
  re = FALSE, compile = FALSE, extra.args = "", clean = TRUE, sup, ...)
}
\arguments{
\item{x}{processed dataframe created by process.data}

\item{ddl}{list of dataframes for design data; created by call to
\code{\link{make.design.data}}}

\item{dml}{list of design matrices created by \code{\link{create.dm}} from
formula and design data}

\item{model_data}{a list of all the relevant data for fitting the model including
imat, Phi.dm,p.dm,Psi.dm,Phi.fixed,p.fixed,Psi.fixed and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.}

\item{parameters}{equivalent to \code{model.parameters} in \code{\link{crm}}}

\item{accumulate}{if TRUE will accumulate capture histories with common
value and with a common design matrix for S and p to speed up execution}

\item{initial}{list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name}

\item{method}{method to use for optimization; see \code{optim}}

\item{hessian}{if TRUE will compute and return the hessian}

\item{debug}{if TRUE will print out information for each iteration}

\item{chunk_size}{specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)}

\item{refit}{non-zero entry to refit}

\item{itnmax}{maximum number of iterations}

\item{control}{control string for optimization functions}

\item{scale}{vector of scale values for parameters}

\item{re}{if TRUE creates random effect model admbcjsre.tpl and runs admb optimizer}

\item{compile}{if TRUE forces re-compilation of tpl file}

\item{extra.args}{optional character string that is passed to admb if use.admb==TRUE}

\item{clean}{if TRUE, deletes the tpl and executable files for amdb if use.admb=T}

\item{sup}{supplemental index values for constructing mvms model}

\item{...}{not currently used}
}
\value{
The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
\item{beta}{named vector of parameter estimates} \item{lnl}{-2*log
likelihood} \item{AIC}{lnl + 2* number of parameters}
\item{convergence}{result from \code{optim}; if 0 \code{optim} thinks it
converged} \item{count}{\code{optim} results of number of function
evaluations} \item{reals}{dataframe of data and real S and p estimates for
each animal-occasion excluding those that occurred before release}
\item{vcv}{var-cov matrix of betas if hessian=TRUE was set}
}
\description{
A function for computing MLEs for MVMS models following Johnson et al 
via ADMB. It works very much like mscjs but with more parameters.
 
It is easiest to call this function through the function \code{\link{crm}}.
Details are explained there.
}
\author{
Jeff Laake <jeff.laake@noaa.gov>
}
\references{
Johnson, D. S., J. L. Laake, S. R. Melin, and DeLong, R.L. 2015. Multivariate State Hidden Markov Models for Mark-Recapture Data. 31:233–244.
}

